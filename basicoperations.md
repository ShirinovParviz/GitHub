## **Базовые операции**

1. <span style="color:Green"> **Создание локальной копии главного репозитория**. 

Для начала нужно перейти в каталог, в котором вы хотите, чтобы появился каталог репозитория, и запустить в нем терминал. Для пользователей Linux/MacOS: запустить Терминал и с помощью команды ***"cd"*** перейти в нужный каталог. Для пользователей Windows: перейти в
Проводнике в нужный каталог, щелкнуть правой кнопкой мыши в окне каталога и в
контекстном меню выбрать пункт *"Git Bash"*. 

После запуска в терминале набрать команду:

    git clone https://github.com/ShirinovParviz/GitHub

В результате в текущем каталоге будет создан подкаталог ***"test"***, содержащий
копию *главного* репозитория. Для работы с репозиторием необходимо перейти в его
каталог командой ***"cd test"***.

---------

2. <span style="color:Green"> **Добавление новых файлов в репозиторий**. 

Давайте создадим в каталоге репозитория ***"test"*** текстовый файл 
<span style="color:red"> ***"first.txt"***</span>
, содержащий строку текста ***"Some text"***. Однако то, что файл появился в каталоге репозитория не означает, что **GIT** его уже отслеживает, нужно указать это явно командой:

    git add "first.txt"

Теперь наш файл находится под наблюдением git. Давайте сохраним изменения в
репозитории и сделаем первый коммит: 

    git commit -­m "My first commit" 

Ключ **"m"** позволяет задать описание коммита. Описание обязательно, иначе
коммит не будет выполнен. 

Теперь давайте создадим каталог **"dir"**, а в нем два текстовых файла **"a.txt"** и **"b.txt"**. Чтобы при добавлении в **GIT** не перечислять их по отдельности, воспользуемся командой:

    git add .

которая добавляет в **GIT** все новые файлы. И снова сохраним: 
   
    git commit ­-m "dir added"
    
-----

3. <span style="color:Green"> **Сохранение изменений файлов**. 

Добавим в файл 
<span style="color:red"> ***"first.txt"***</span> 
еще одну строчку ***"Some more text"*** (не забудьте сохранить файл!). И снова закоммитим изменения.
<br>Однако если мы воспользуемся известной нам командой: <br>

    git commit ­-m "more text added to first.txt"

то мы получим сообщение, что коммитить в общем­то нечего. Почему? Дело в том,
что **GIT** опять же не знает, какие именно из измененных файлов мы хотим сохранить.
Чтобы указать это явно, необходимо воспользоваться описанной выше командой
git add. В то же время самый частый сценарий ­ сохранить изменения во всех
файлах. Для этих целей в команде **"git commit"** есть ключик ­a. 

Итого наша команда будет такой:

    git commit -­a -­m "more text added to first.txt"

Чтобы меньше запоминать, Вам будет достаточно для всех коммитов пользоваться
командой именно такого вида. 
<br> Однако помните, что ключ ­a позволяет учесть изменения только в файлах, уже
находящихся под наблюдением **GIT**. А новые файлы перед коммитом необходимо
предварительно явно добавить командой ***"git add"***.

------

4. <span style="color:Green"> **Отправка изменений в главный репозиторий**. 

К этому моменту мы уже немало сделали в нашей локальной копии репозитория, однако если Вы обновите веб­страничку с *главным* репозиторием, Вы увидите, что в нем никаких изменений нет. Как их туда внести? Для этого используется команда: 

    git push

В процессе выполнения команды от Вас потребуется ввести Ваш и логин и пароль
от аккаунта на **GitHub**. Когда после успешного завершения команды мы обновим
страничку с главным репозиторием, мы увидим, что теперь его содержимое
совпадает с нашим локальным репозиторием.

----

5. <span style="color:Green"> **Получение изменений из главного репозитория**. 

Смоделируем ситуацию, в которой нам это пригодится. Для этого откроем еще один терминал в каталоге, отличном от того, в котором лежит наш локальный репозиторий. И создадим еще одну локальную копию главного репозитория (как ­ описано выше). Итого у нас теперь есть два локальных репозитория: первый (старый) и второй (только что созданный). Представим, что второй репозиторий на самом деле находится на другом компьютере и с ним работает второй участник. И он решает внести какие­то изменения в файл 
<span style="color:red"> ***"first.txt"***</span> 
(например, добавим туда еще одну строчку текста), находящийся в его локальной копии, т.е. во втором репозитории. Сохраняем файл и коммитим:
 
    git commit ­a ­m "more changes in first.txt"

и отправляем изменения на сервер: 

     git push

Сейчас у нас синхронизированы главный и второй локальный репозитории, но первый локальный отстает. Ему нужно получить изменения из главного репозитория командой:

    git pull

Ура, теперь у нас везде одинаковые версии. 

-------

6.<span style="color:Green"> **Разрешение конфликтов**. 

В заключение рассмотрим еще один частый сценарий, распространенный при одновременной работе нескольких человек. Давайте в нашем первом локальном репозитории внесем еще какие­нибудь изменения в файл 
<span style="color:red"> ***"first.txt"***</span>
, закоммитим и отправим их в главный репозиторий. А затем во втором локальном репозитории создадим файл 
<span style="color:red"> ***"second.txt"***</span> 
и тоже закоммитим. Однако если теперь из второго репозитория мы попробуем сделать <span style="color:blue"> ***"git push"***</span>, 
то получим ошибку из-­за конфликта изменений. Почему? Для простоты можно считать, что при отправке изменений в локальном репозитории должна быть версия, основанная на версии главного репозитория. Тогда как мы во втором репозитории пока ничего не знаем про последний коммит 
<span style="color:red"> ***"first.txt"***</span>. 
Что делать? Сначала нам нужно получить изменения из главного репозитория, затем объединить их с нашими изменениями, и то, что получилось, отправить на главный репозиторий. Звучит непросто, но на самом деле первые два шага сама умеет делать команда 
<span style="color:purple"> ***"git pull"***</span>. 
Она достаточно умна, чтобы понять, что в нашем случае надо обновить файл 
<span style="color:red"> ***"first.txt"***</span>
 и добавитьsecond.txt. После чего нам остается просто отправить изменения командой 
 <span style="color:blue"> ***"git push"***</span>. 
Итого получаем, что при отправке изменений безопасно пользоваться двумя
последовательными командами:  

    git pull (проверить на наличие новых изменений в репозитории и, если они есть, выкачать их и объединить с локальными изменениями) 
> 

    git push  (отправить изменения в репозиторий)

Таким образом, **GIT** умеет разрешать конфликты самостоятельно. Но к сожалению не все. Если бы мы вместо создания 
<span style="color:red"> ***"second.txt"***</span> 
во втором репозитории тоже изменили 
<span style="color:red"> ***"first.txt"***</span>, 
то мы бы имели две измененные версии одного файла и здесь уже **GIT** самостоятельно разрешить конфликт не может: нужно вмешательство человека. При грамотно спланированной работе команды, такие ситуации встречаются редко, и мы их рассматривать не будем. Интересующиеся могут посмотреть в интернете или в справке **GIT** по команде ***merge*** в разделе ***"How to resolve conflicts"***.